{"meta":{"title":"Oceania's","subtitle":"Yep, you are right.","description":"oceania | blog | web | vps | hexo","author":"oceania ( 吴 洲洋 )","url":"http://www.wuzhouyang.cn"},"pages":[],"posts":[{"title":"《你不知道的javascript》小记","slug":"you-dont-know-javascript","date":"2017-06-13T09:02:28.000Z","updated":"2017-06-13T09:07:47.000Z","comments":true,"path":"you-dont-know-javascript/","link":"","permalink":"http://www.wuzhouyang.cn/you-dont-know-javascript/","excerpt":"","text":"作用域与闭包javascript 也能称为一门编译语言，由浏览器引擎将js代码转为机器码传统编译语言在源代码执行之前的三个步骤 词法分析。将代码块拆分为词法单元（根据空格分开） 语法分析。将词法单元转换为抽象语法树（AST） 代码生成。将AST转换为可执行代码（机器指令）作用域相关的三个角色 引擎。负责整个javascript程序的编译与执行 编译器。负责语法分析及代码生成· 作用域。负责收集和维护由所有声明的标识符组成的一系列查询，并实施一套非常严格的规则 三个的合作：编译器通过语法分析生成代码，引擎执行代码，查询变量时由作用域协助查询引用 LHS：找到变量容器本身，对其赋值 RHS：取到某个变量的值作用域嵌套从底层往顶层查询，如果是LHS且顶层查询不到所需标识符，在非严格模式下，会自动生成一个全局标识符，在严格模式下会抛出ReferenceError；如果是RHS且顶层查询不到所需标识符，直接抛出ReferenceError词法作用域定义在词法阶段的作用域，也就是我们在写代码的时候就已经确定的作用域遮蔽效应作用域查找会在找到第一个匹配的标识符时停止欺骗词法作用域 eval。可以动态将字符串视为可执行代码在调用的位置执行，改变相关的词法作用域，性能及安全性有问题，已被废弃 with。重复引用同一个对象中的多个属性的快捷方式。例如：var test=&#123;&#125;// a 和 b 会被泄漏到全局中with(test)&#123; a='a', b='b' ...&#125; with块中其实是创建了一个新的词法作用域，在里面声明的东西会自动被定义到with所处的函数作用域中 函数作用域属于这个函数的全部变量都可以在整个函数的范围内使用及复用 函数声明与函数表达式区别看法function如果是声明中的第一个词，那么就是函数声明，否则是函数表达式 块作用域javascript中有块作用域效果的结构： with。在with块中的是一个独立的作用域 try...catch...语句。catch中捕获到异常只能在其块中使用 ES6 支持块级作用域，关键字有let、const变量提升 变量和函数在内的所有声明都会在任何代码被执行前首先被处理，定义声明是在编译阶段进行，赋值声明会在原地等待执行阶段 函数声明会被提升，函数表达式不会被提升 函数内的变量提升会被提升到函数的顶部 函数会被优先提升，然后才是变量闭包 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数时在当前词法作用域之外执行 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包一个简单的现在模块机制var MyModules=(function()&#123; //单例 var modules=&#123;&#125; //模块定义 //name 模块名称 //deps 模块依赖 //main 模块主体 function define(name,deps,main)&#123; for(var i=0;i&lt;deps.length;i++)&#123; //取到依赖实体 deps[i]=modules[deps[i]] &#125; //存储当前定义模块 modules[name]=main.apply(main,deps) &#125; //获取模块 function get(name)&#123; return modules[name] &#125; return &#123; define:define, get:get &#125;&#125;)()//测试MyModules.define('a',[],function()&#123; function say(sth)&#123; console.log(sth) &#125; return &#123; say:say &#125;&#125;)MyModules.define('b',['a'],function(a)&#123; a.say('I am b')&#125;)MyModules.get('b')() // 'I am b' this与原型关于this this在任何情况下都不指向函数的词法作用域，作用域“对象”无法通过javascript访问，它存在于javascript引擎内部 this是在运行时绑定的，它的上下文取决于函数调用的方式this绑定规则 默认绑定：独立函数调用，非严格模式下直接绑定到全局上下文 隐式绑定：被某个对象包含或拥有、调用，直接绑定到此上下文对象中，有可能造成隐式丢失（把对象包含的函数赋值到另外的变量中并调用） 显式绑定：调用call、apply、bind强制改变执行上下文 new绑定：使用new来调用函数，会创建一个全新的对象、这个新对象会绑定到函数调用的this绑定规则优先级new&gt;显式绑定&gt;隐式绑定&gt;默认绑定参数简单柯里化function klh(a,b)&#123; ...&#125;var dmz= Object.create(null)klh.apply(dmz,[1,2])// orklh.bind(dmz,1)klh(2) ES6的箭头函数 箭头函数不使用四种标准规则，而是根据外层作用域来决定this,箭头函数会继承外层函数调用的this绑定 箭头函数没有一个自己的this，但当你在内部使用了this，常规的局部作用域准则就起作用了，它会指向最近一层作用域内的this对象 6种主要类型：string,number,boolean,null,undefined,object 简单基本类型：string,number,boolean,null,undefined 内置对象：String,Number,Boolean,Object,Function,Array,Date,RegExp,Error属性描述符ES5中所有的对象属性都有对应的属性描述符，一个属性都有4个描述符：value（数据值）、writable（可写）、enumerable（可枚举）、configurable（可配置）修改属性描述符（可配置）：Object.defineProperty获取属性描述符：Object.getOwnPropertyDescriptor判断是否存在属性（会检查原型）：(&#39;x&#39; in myObject)判断是否存在属性（只检查对象本身）：myObject.hasOwnProperty(&#39;x&#39;)ES6 for...of直接遍历值：数组有内置的@@iterator，如果想给某个对象支持for...of，可以添加一个@@iterator对象：var myObject=&#123; a:1, b:2, c:3&#125;Object.defineProperty(myObject,Symbol.iterator,&#123; enumerable:false, writable:false, configurable:false, value:function()&#123; var _this=this var index=0 var keys=Object.keys(_this) return &#123; next:()=&gt;&#123; return&#123; value:_this[keys[index++]], done:(index&gt;keys.length) &#125; &#125; &#125; &#125;&#125;) 类 javascript 中的类与其他语言中的类完全不同 类意味着复制 类的多态、继承都是通过复制而来，传统类被实例化时，它的行为会被复制到实例中；类被继承时，行为也会被复制到子类中 javascript 并不会像类一样自动创建对象的副本（复制） 可以通过混入来实现伪多态，实际上只是遍历另一个对象的所有属性和函数、通过筛选复制唯一的到新的对象上[[prototype]]几乎所有的对象在创建时[[prototype]]属性都会被赋予一个非空的值（Object.create(null)除外） 操作对象不存在某个属性，但是原型链上存在某个属性，此时在操作对象声明同名属性（=操作符）会发生的三种情况： 原型上的属性没有标记为只读，则操作对象生成同名属性，造成屏蔽效果 原型上的属性标记为只读，则无法修改现有属性或者创建新属性 原型上的属性有setter，则一定会调用此setter，不会在操作对象上添加新属性使用Object.defineProperty则没有上述问题 继承意味着复制操作，javascript默认并不会复制对象属性。相反，javascript会在两个对象之间创建一种关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。 new会挟持所有普通函数并用构造对象的形式来调用他，函数首字母大写只是一种规范 待更新","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.wuzhouyang.cn/tags/javascript/"}]},{"title":"vue-cli 2 中默认打包编译 sass 后造成 -webkit-flex 消失问题","slug":"vue-cli-2-sass-webkit-flex","date":"2017-05-18T07:49:17.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"vue-cli-2-sass-webkit-flex/","link":"","permalink":"http://www.wuzhouyang.cn/vue-cli-2-sass-webkit-flex/","excerpt":"","text":"这个是小问题，主要为了吐槽 最近采用vue和purecss在制作自己的简历，原因是这俩货都是轻量级的，实在让人喜欢。不过是我第一次使用vue，也就简单地看了些文档。之前使用angular2的时候是自己搭的构建环境，觉得很费时间虽然能学到不少东西，所以这次直接用了vue-cli上手，毕竟打包后加gzip才16kb。 简历仔细揣摩了很久，终于到了比较满意的阶段，寻思着直接打包后发布了，所以打包后本地运行了一下，PC端一切完美运行。手机呢？拿起还装着IOS 8.3的5s的safari访问了一下，出乎意料地乱了布局。此后，我尝尽了许多方法，我一直以为是我样式布局的问题，找遍了所有可能影响布局的代码，始终不知道是哪里出现问题，后来我才清醒过来 – 为什么在开发模式下没有任何问题，在打包生产后倒出现了问题？所以肯定问题源头是出在打包的时候。 苦于手机端 safari 没法调试，为了能查看移动端访问时的 DOM 结构，我使用了Weinre，调试的时候还是什么都看不出，只能一个一个样式关闭看看会不会影响到布局。。。后来发现了问题 但我取消勾选 display 属性的时候，布局意外地正确了，这个时候我又在开发模式下调试看看同样的样式 看来已经找出布局错乱的源头了，本来应该是 display:-webkit-flex 变成了 display:-webkit-box 导致布局出现了问题。那就是Vue-cli的问题了，可能通过某些配置可以解决这个问题，于是上 google 搜了一番，得到了正确的解决方法 由于使用的是 Vue-lic 2，所以直接在package.json中修改一下browserslist选项即可。默认为\"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt; 8\"] cli使用的autoprefixer插件会自动搜寻browserslist中匹配的浏览器列表，生成处理比较符合这些浏览器的样式。我觉得默认的选项值选中的浏览器都比较先进，所以插件觉得不用使用兼容的前缀来处理样式，而我的safari又比较古老，所以才导致-webkit-flex丢失问题。最后稍作修改，便完美解决。 \"browserslist\": [ \"last 10 versions\", \"not ie &lt; 8\"]","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.wuzhouyang.cn/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"http://www.wuzhouyang.cn/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://www.wuzhouyang.cn/tags/vue-cli/"},{"name":"sass","slug":"sass","permalink":"http://www.wuzhouyang.cn/tags/sass/"}]},{"title":"购入nikor 50mm f1.4 老镜头一枚","slug":"new-nikor-50-1-4","date":"2017-05-10T10:55:29.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"new-nikor-50-1-4/","link":"","permalink":"http://www.wuzhouyang.cn/new-nikor-50-1-4/","excerpt":"","text":"记录于2017年5月10号 富士的 16-50mm 套头只适合拍风景，广角不错。无奈人像拍出来不怎么样，主要是追求大景深，又无奈富士镜头十分昂贵，摄影穷三代是有道理的。我也只是玩玩而已，所以淘了个手动定焦老头，主要是便宜。看看 1.4 的大光圈着实心动，于是就购入一枚 nikor 50mm f1.4","categories":[{"name":"My Life","slug":"My-Life","permalink":"http://www.wuzhouyang.cn/categories/My-Life/"}],"tags":[{"name":"无反","slug":"无反","permalink":"http://www.wuzhouyang.cn/tags/无反/"},{"name":"镜头","slug":"镜头","permalink":"http://www.wuzhouyang.cn/tags/镜头/"}]},{"title":"写个小小图片布局插件 -- OCask.js","slug":"photos-layout-plugin-ocaskjs","date":"2017-05-03T08:18:13.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"photos-layout-plugin-ocaskjs/","link":"","permalink":"http://www.wuzhouyang.cn/photos-layout-plugin-ocaskjs/","excerpt":"","text":"二话不说上链接 https://github.com/wuzhouyang/OCask.js 由于在设计制作自己的简历中，想要把项目的截图以一种更好的方式展示出来，但是css实现的效果有局限，兼容性是个问题，所以 google 了许久，参考了别人的一些实现思路，自己完善并增强了功能，写了一个小小的布局插件。兼容主流浏览器，以及 IE9+ 。至于 IE8- ，不管了，可以说花了30% 的时间在处理兼容 IE8 上，无奈问题太多，遂放弃 ！ 以下摘至 github 仓库 README.MD 中文版 OCask.js – 相册图片布局的小插件截图 用法git clone https://github.com/wuzhouyang/OCask.js.git 在你的 html 中使用压缩版本&lt;body&gt; ... &lt;script src=\"ocask.min.js\"&gt;&lt;/script&gt;&lt;/body&gt; 配置 container : 布局容器 DOM baseHeight : 一行的最小高度，默认为 200px imgArr : 存放你想要显示的图片 url 的数组 isGap : 如何显示最后一行图片，设为true则行高为配置的最小高度，设为false则填满整行宽度，默认为false rowClass : 为行容器添加样式类 imgClass : 为每一个图片添加样式类 例子#ex&#123; width: 1200px; margin:auto; margin-top: 50px;&#125;.shadow&#123; box-shadow: 0 0 50px rgba(0,0,0,0.8);&#125; var oc=new OCask(&#123; container:document.getElementById('ex'), baseHeight:200, imgArr:[ 'http://imgsrc.baidu.com/baike/pic/item/b151f8198618367a608c040a2b738bd4b21ce5e4.jpg', 'http://imgcache.cjmx.com/star/201605/20160530131804447.jpg', 'http://www.cnidea.net/toutiao/u/20160701/161822310132588621419.jpg', 'http://gb.cri.cn/mmsource/images/2011/06/29/ab20110629213.jpg', 'http://www.lzbs.com.cn/images/2006-07/01/sat200D.JPG', 'http://img.kj-cy.cn/uploads/litimg/20160411/1460363212437848.jpg', 'http://singerimg.kugou.com/uploadpic/softhead/400/20140219/20140219104100727871.jpg', 'http://vpic.video.qq.com/82684169/t0344b49der_ori_3.jpg', 'http://a4.att.hudong.com/37/75/01100000000000144730751999065_s.jpg', 'http://imgsrc.baidu.com/forum/w=580/sign=9a2f5024bf99a9013b355b3e2d950a58/c124bc315c6034a8dbc034b1cc134954092376e5.jpg', 'http://imgsrc.baidu.com/forum/pic/item/0494a4c27d1ed21b94e8ac09ad6eddc451da3f3d.jpg', 'http://www.ym360.cn/upload/img/3716338.jpg' ], isGap:false, imgClass:'shadow'&#125;)oc.getImgs() 如图 Gap如果你不想要最后一行填满宽度，可以设置isGap为true，然后如图 Responsive如果你在使用 CSS3 的媒体查询中想要图片自适应布局容器的宽度，你可以设置responsive为true，下面是个例子 #ex&#123; width: 1200px; margin:auto; margin-top: 50px; margin-bottom: 50px;&#125;@media screen and (max-width:768px)&#123; #ex&#123; width: 600px; &#125;&#125; var oc=new OCask(&#123; ... responsive: true&#125;)oc.getImgs() 当你改变页面大小的时候，会自适应，如图","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.wuzhouyang.cn/tags/javascript/"},{"name":"github","slug":"github","permalink":"http://www.wuzhouyang.cn/tags/github/"}]},{"title":"使用 gulp 来优化自己的 hexo 博客","slug":"use-gulp-to-optimize-hexo","date":"2017-04-20T10:00:49.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"use-gulp-to-optimize-hexo/","link":"","permalink":"http://www.wuzhouyang.cn/use-gulp-to-optimize-hexo/","excerpt":"","text":"由于 hexo 是第三方的静态博客工具，所以无论是开发模式还是生成模式下的项目结构都不是按照自己的意愿来的，也是，毕竟是方便了人们写博客，重心是在博文中而不是捣鼓环境中。但是作为一名有强迫症的前端，还是觉着手痒痒，毕竟是自己的博客，也想要它更加的完美。因为 markdown 文章最终都被解析成一个个的 html 页面，而且项目结构并不是我们所设计的，所以我使用第一个接触的构建工具 – gulp，顺便回炉一下对这个工具的使用（其实重点还是回炉一下 gulp 技术）。 优化前后以我的博客为例，这是本地预览没做任何优化的效果，本地预览命令为 hexo s，默认4000端口即是 可以看到请求连接数太多，而且耗费的流量也挺多的。但是，事实并不是这样，GitHub 和 Coding 的 pages 服务默认开启了 gzip 功能，使得网页所耗费的流量大大减少 可以看到耗费的流量几乎少了一半。这个是博客发布上服务器后查看的数据，如果我们想在本地查看，可以执行 hexo g来生成最终的博客，然后利用superstatic来搭建运行本地的一个静态服务器来运行我们的博客，来个简单的步骤安装superstaticnpm install superstatic --save-dev 创建npm script任务，也就是项目package.json中的scriptskey值\"scripts\": &#123; \"server\": \"superstatic public/ --port 4001 --host 0.0.0.0 --gzip\", ...&#125; superstatic默认相对根目录，而我们hexo g生成的博客就在根目录下的public文件夹，所以将静态网站根目录设为public即可，端口呢随便定义，不被占用即可，然后为了模拟 pages 服务的 gzip，我们也开启此功能。接下来直接使用npm run server即可预览自己通过 hexo 生成的博客了。不出所料，hexo g所做的动作仅仅是生成了静态页面，并没有做任何优化，至于流量少了一半，仅仅是服务端 gzip 的功能罢了。为此，我花了点时间用 gulp 简单优化了一下，效果如下 可以看到，优化后的请求连接数少了一半，流量也在开启 gzip 的情况下减少了十几k。这十几k全是压缩插件的功劳，但毕竟压缩空间有限，这个量也是能接受的。请求连接数呢也重要关系到页面加载的速度，这少了一半阻力，相信页面完成加载也快些，最重要的是满足了自己的强迫症。 待更新… …","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"npm script","slug":"npm-script","permalink":"http://www.wuzhouyang.cn/tags/npm-script/"},{"name":"hexo","slug":"hexo","permalink":"http://www.wuzhouyang.cn/tags/hexo/"},{"name":"gulp","slug":"gulp","permalink":"http://www.wuzhouyang.cn/tags/gulp/"}]},{"title":"golang map类型数据反射转为对应struct类型数据","slug":"go-map-to-struct","date":"2017-04-18T07:35:26.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"go-map-to-struct/","link":"","permalink":"http://www.wuzhouyang.cn/go-map-to-struct/","excerpt":"","text":"其实 map 类型已经能满足需求了，只不过取值的时候需要通过属性字面量取值，而且感觉不符合面向对象、强类型的思路，所以记录一下如何将 map 结构数据转化为 struct 类型 引入包import ( \"fmt\" \"reflect\") 创建测试 struct// Person 测试结构 成员需首字母大写type Person struct &#123; Name string Age int&#125; 创建主要反射处理函数func mapReflect(item interface&#123;&#125;) Person &#123; //初始化 Person struct 数据（指针） personItem := new(Person) //得到 personItem 所指对象 ref := reflect.ValueOf(personItem).Elem() //断言，判断是否 map 结构 temp, can := item.(map[string]interface&#123;&#125;) if can &#123; for k, v := range temp &#123; //将 map 结构得到的属性和值 设置给 personItem ref.FieldByName(k).Set(reflect.ValueOf(v)) &#125; &#125; else &#123; personItem = nil &#125; //将指针值返回 return *personItem&#125; 来个函数打印出结果func testStruct(p Person) &#123; fmt.Println(p.Name, p.Age)&#125; main函数定义一个能与 Person Struct 相对应的 map 数据，然后就能调用主要的处理函数了func main() &#123; person := map[string]interface&#123;&#125;&#123;\"Name\": \"oceania\", \"Age\": 24&#125; testStruct(mapReflect(person))&#125; go run main.go走起，可以看到 map 数据都将直接通过 struct 读取出来oceania 24","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.wuzhouyang.cn/tags/golang/"}]},{"title":"搭建双线（github + coding）hexo博客","slug":"create-hexo-double-cname","date":"2017-04-14T08:32:14.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"create-hexo-double-cname/","link":"","permalink":"http://www.wuzhouyang.cn/create-hexo-double-cname/","excerpt":"","text":"啰嗦因为买了自己的 vps，所以有捣鼓过搭博客的经验。之前搭建过 Wordpress 、Jekyll，说实在, Wordpress 更像是一套完善的程序，只要简单在 vps 上搭建 LNMP 或者等等环境，就能在 web 中通过界面操作和写文章，主题之类的也非常多，之前为了主题选了很久而且自己修改了一些，后来发现我的重心偏离了，浪费了太多时间，而且 Wordpress 的优点也是缺点–臃肿。之后听说 Jekyll 不错，与 Wordpress 不同的是 Jekyll 是静态页面工具，轻量、速度快，而且支持 markdown，所以我又捣鼓了一下，个人觉得它的命令比较杂，而且依赖 ruby， mac 上还好， window 上捣鼓真心烦。所以最终转向了 Hexo，依赖 Node.js，有着 jekyll 的优点，实乃前端必备啊。不多说了，下面贴出搭建 Hexo 以及配置双线的方法还有心得。 Github PagesGithub Page 就是我们必须用到的服务了，可以看看官方的说法： GitHub Pages allow you to publish web content to a github.com subdomain named after your username. With Pages, publishing web content becomes as easy as pushing to your GitHub repository. 也就是说我们可以通过其服务来将我们的博客托管到其服务器上，Github 还提供子域名供解析。我们只要把博客 push 到仓库，就能随时更新自己的博客了。 新建 Github Pages 仓库 请先拥有一个 Github 账户！点击右上角头像新建一个仓库 仓库的名称必须是 用户名.github.io，这是 Github Pages 规定的，为了方便测试，也勾选了使用 README.MD 初始化选项 接下来在项目中新建一个 index.html 进行测试 打开浏览器访问 username.github.io 就可以看到 index.html 的内容了 配置 GitHub 对应的密钥 window 下使用 Git Bash，Mac 和 Linux 使用 terminal因为使用 Hexo 都是一键部署的，而且为了实现一键部署到多个托管平台，所以这里是用 ssh 连接远程，关于详细配置私钥和迷钥的可以参考另一篇博文《git ssh 的私钥与公钥》，这里直接贴代码 生成 ssh 密钥ssh-keygen -t rsa -f ~/.ssh/github 得到一堆密钥，私钥为 github，公钥为 github.pub，可以列出查看ls -a ~/.ssh 添加 config 配置文件,并通过 vi 编辑touch ~/.ssh/config &amp; vi ~/.ssh/config 填写相关的配置信息到 config 中,注意有缩进Host github HostName github.com IdentityFile ~/.ssh/github 复制公钥 github.pub 内容部署到 Github 的 ssh key 上面 添加完成后会看到 ssh keys 列表 测试 ssh 到 GitHub 的连接ssh -T git@github 测试成功会看到如下到提示 至此，GitHub pages 服务算是已经简单搭好了 Coding PagesCoding Pages 是国内代码托管平台，为了实现双线搭建 Hexo，我把国内线路的访问托管到 Coding 上面，所以请先注册一个 coding 账户，新建一个 Coding Pages 项目仓库，为了直接能使用username.coding.me域名，名称必须与自己的账户名一样 打开项目，初始化一下仓库 添加一个 index.html 方便测试 打开侧边栏的Pages 服务，将master作为部署分支，保存即可 打开浏览器，即可成功访问 username.coding.me 配置 Coding 密钥通过 ssh 连接 Coding 时也需要进行认证，同样的需要配置对应 Coding 的密钥ssh-keygen -t rsa -f ~/.ssh/coding 添加 config 配置Host coding HostName git.coding.net IdentityFile ~/.ssh/coding 复制公钥 coding.pub 的内容部署到 Coding 服务端 没什么问题即可通过 ssh 连接测试ssh -T git@coding 创建 Hexo 博客 确保安装了 Git 和 Node.js 安装 Hexo-clinpm install hexo-cli -g 确保安装了 Hexo-cli，查看版本，看到版本信息即证明安装成功hexo -v cd到想要储存博客文件夹的目录路径，初始化一个 Hexo 博客，这里我命名为oceania_bloghexo init oceania_blog Hexo 3.0 init 的时候已经会自动安装依赖了，如果发现根目录没有 node_modules 文件夹，可以手动安装依赖cd oceania_blog &amp; npm install 接下来直接使用 Hexo 自带命令就能本地预览你的博客了hexo s 浏览器打开 localhost:4000，可以看到一个简单的博客已经展现出来 部署 Hexo 到 GitHub Pages博客根目录先安装插件依赖npm install hexo-deployer-git --save 打开博客根目录的 Hexo 配置文件 _config.yml，找到 deploy 节点并添加配置deploy:- type: git repo: github: git@github:wuzhouyang/wuzhouyang.github.io.git name: wuzhouyang email: oceaniawzy@gmail.com branch: master 由于我在.ssh/config文件中写的是别名，也就是github对应的是主机github.com，而仓库本来的连接是git@github.com:wuzhouyang/wuzhouyang.github.io.git，所以必须把连接改为git@github:wuzhouyang/wuzhouyang.github.io.git这里的name和email主要是 git 提交的用户信息，将会被显示在提交人那里，方便开发人员清楚提交人信息，如果不填的话会默认查找全局的 git 配置中的user.name和user.email，如果在全局的配置中也没有相关信息，则会直接使用所在电脑主机的用户名和主机名 现在，可以使用命令直接部署生成的博客到服务器端了hexo d 可以看到 git 已经是提交成功了 GitHub 的仓库中已经有了新生成的博客文件，打开浏览器访问对应的域名 username.github.io，可以看到博客已经被正常解析 部署 Hexo 到 Coding同样的在 Coding 上获取项目对应的 ssh 地址，然后在博客的_config.yml找到deploy节点完善配置deploy:- type: git repo: github: git@github:wuzhouyang/wuzhouyang.github.io.git coding: git@coding:wuzhouyang/wuzhouyang.git name: wuzhouyang email: oceaniawzy@gmail.com branch: master 最好先清除一下缓存rm -rf .deploy_githexo clean 然后就执行hexo d能正确同时部署到 Coding 平台上了，可打开username.coding.me看看最终效果 域名解析到这里，其实一个简单的个人博客已经实现了，也能同时部署到两个平台上，但是貌似部署到两个平台上后并没有什么用啊，访问的时候还是得分不同的域名，所以，下面就记录一下让这些不同的域名指向你自己域名的方法，实现双线访问，也就是海外访问时实际使用的是 GitHub 的域名指向，而国内访问时使用的是 Coding 的域名指向 首先你得拥有一个自己的域名 到域名商控制台上添加域名解析，我的是在阿里云上面设置 简单说明一下，CANME记录类型呢是将域名解析到另一个域名，因为这里我们必须把username.github.io和username.coding.me解析到自己的域名上，所以使用此记录类型；主机记录@代表空，例如我的域名为wuzhouyang.cn，便可以直接解析识别，主机记录www代表可以解析识别www.wuzhouyang.cn，这样以来，无论是输入哪一个，都会解析到同样的地址中；解析线路分海外和国内，海外主要设置 GitHub 的域名，国内主要设置 Coding 的域名 配置完成后即可访问自己的域名了，但是会发现无论是国内还是海外的情况下，都返回了404 接下来就来解决此问题 GitHub 的方法主要是添加一个CNAME文件供识别，在博客的source文件夹下新建一个CNAME文件，不带任何后缀，内容输入自己的顶级域名，我的就是wuzhouyang.cn，然后清空一下 Hexo 缓存后提交部署hexo clean hexo d 完成后即可全局翻墙访问自己的域名看看能不能正确解析 Coding 平台提供了绑定域名的功能，只需到项目的控制台的 Pages服务 中设置即可，好处是可以绑定多个域名 然后就可以回墙内试试自己的域名能不能访问了 如果要求证双线路是否正确配置了，可以用在线 DNS 查询结果 看到多个不同的域名则证明成功了 做记录有些累，先到此，以后再做修改","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"github","slug":"github","permalink":"http://www.wuzhouyang.cn/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://www.wuzhouyang.cn/tags/hexo/"},{"name":"coding","slug":"coding","permalink":"http://www.wuzhouyang.cn/tags/coding/"}]},{"title":"mac 下 git 通过 https 传输的疑惑","slug":"mac-git-https-osxkeychain","date":"2017-04-13T05:48:23.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"mac-git-https-osxkeychain/","link":"","permalink":"http://www.wuzhouyang.cn/mac-git-https-osxkeychain/","excerpt":"","text":"都说 git 通过 https 方式 clone 下来的项目要 push 的话每次都需要输入验证自己的账户和密码，但是据我在自己的 Mac 上操作，并不是如此，让我心生疑惑，我 push 的时候貌似只有第一次需要输入自己相关对应的账户和密码（无论 github 还是 coding），之后的每次提交都会直接完成。本着好奇的心里，我还是翻了翻 git 的文档，发现原来对于 https ，git 还有凭证存储这一说： 幸运的是，Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项： 默认所有都不缓存。 每一次连接都会询问你的用户名和密码。 “cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。 “store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。 如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。 如果你使用的是 Windows，你可以安装一个叫做 “winstore” 的辅助工具。 这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。 可以在 https://gitcredentialstore.codeplex.com 下载。 osxkeychain由于使用的是 Mac，可能是符合上面几点所说的 “osxkeychain” 模式，可以直接看看事实是不是如此：git config credential.helper 可以看到果然应用了 osxkeychain 模式 我想可能是 Mac 下 git 的默认配置就是如此。那什么是 osxkeychain 模式呢，其实，从名字上就可以判断出这种模式是依赖于 osx 上的 keychain，也就是钥匙串 钥匙串是 Mac 内置的密码管理工具，各种程序的密码在某些条件下会自动被钥匙串收录，所以可以很简单地知道 git 在 osxkeychain 模式下是会在第一次输入验证账户密码的时候将相关密码信息存储到了钥匙串中。打开钥匙串可以很清晰地看到我自己的 GitHub 和 coding 中存储的信息 上面清楚写着存储的时间，也就知道了最近一次输入验证是什么时候。为了验证此钥匙串是不是就是 git 自动填写的密码，我把其中一个 coding.net 的删掉，再通过 https 方式 push coding 上的项目，果不其然，我必须填写账户信息了 最后，git 文档说钥匙串储存的密码是加密的，我通过右键选项将密码 copy 到粘贴板 然后会要求输入电脑账户的密码，最终粘贴到别的地方，得到的却是明文密码。但是这并不是个大疑惑，或许文档说的加密是指需要通过电脑主机账户的验证，毕竟如果擅自将密码给加密了，那就肯定无法通过 github 或者是 coding 的验证了。","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"github","slug":"github","permalink":"http://www.wuzhouyang.cn/tags/github/"},{"name":"coding","slug":"coding","permalink":"http://www.wuzhouyang.cn/tags/coding/"},{"name":"git","slug":"git","permalink":"http://www.wuzhouyang.cn/tags/git/"},{"name":"mac","slug":"mac","permalink":"http://www.wuzhouyang.cn/tags/mac/"}]},{"title":"购入一款 lofree mac机械键盘","slug":"new-keyboard-lofree","date":"2017-04-09T07:45:06.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"new-keyboard-lofree/","link":"","permalink":"http://www.wuzhouyang.cn/new-keyboard-lofree/","excerpt":"","text":"记录于2017年4月9号 由于对 MacBookPro 有些保护欲，所以键盘上膜了，手感不好，故入了一国产青轴机械键盘。","categories":[{"name":"My Life","slug":"My-Life","permalink":"http://www.wuzhouyang.cn/categories/My-Life/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.wuzhouyang.cn/tags/mac/"}]},{"title":"git ssh 的私钥与公钥","slug":"git-key","date":"2017-04-09T02:39:53.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"git-key/","link":"","permalink":"http://www.wuzhouyang.cn/git-key/","excerpt":"","text":"在 github 或者 coding 中如果我们要 clone 一个项目通常有两种方式，一种是用过 https 直接 git clone 下来，这种方式的 clone 不用经过账户验证即可完成，但是在每次 push 的时候都会要求输入正确的账户与密码（当然，可以通过某些模式和配置来实现只需要一次输入，参考另一篇短记录《mac 下 git 通过 https 传输的疑惑》）；一种是用过 ssh 方式 clone，这种方式的 clone 要求你是项目的相关负责人，也就是说必须通过相关的验证才能正确的 clone 下来，然后在每次 push 的时候都不用输入账户和密码，而这种验证方式则是用过配置公钥与私钥来完成。 生成私钥与公钥window 用户需要打开 git bash，mac 和 linux直接使用自带 terminal 即可。可以先看看此前有没有已经存在相关的密钥ls -a ~/.ssh 如果并没有看到关于 id_rsa、id_rsa.pub 相关内容，那么可以放心接下来的步骤，如果是已经存在了，证明你已经弄过了，有必要的话也可以删除重来实验一次，反正结果都是不会影响到什么的。主要以 GitHub 为例。为了实验，我清空了本机里面所有已有的密钥，并且在 GitHub 上新建一个用于测试的仓库。如图复制了新仓库的 ssh 链接 打开 terminal 或者 git bash 选择合适的文件夹路径试图进行 clone，不出意料会得到如下阻拦信息 这里主要的报错是下面这句而不是那个警告： Permission denied (publickey). 可以知道，公钥验证失败。接下来就让我们来生成一对密钥。主要用到 ssh-keygen 命令ssh-keygen -t rsa -f ~/.ssh/github -t 代表加密类型，一般为rsa，-f为自定义文件名，这里的 github 就是密钥储存的文件名，最好把 ~/.ssh/路径加上，或者你必须到用户的.ssh 目录下执行此操作出现输入密码提示的地方直接回车即可，这里密码用于以后链接 ssh 的时候输入，也没有这种必要，所以就直接enter键跳过了 完成后在.ssh文件夹下会生成一对密钥ls ~/.ssh github 就是新生成的私钥，github.pub 就是新生成的公钥。公钥主要用于部署到服务器端，私钥主要用于解密服务器端通过公钥加密的数据，所以，接下来我们需要将公钥部署到 GitHub 上面去，来到 GitHub 控制台到 setting 中，创建一个 ssh key 复制新生成的公钥的内容到控制台的 key 中，title随便填，无所谓.就像下图 因为这只是公钥内容，不怕泄漏，所以也就可以贴出来。 处理私钥接下来就可以测试一下能不能正确地链接 GitHub 了，输入ssh -T git@github.com 出现错误了，还是公钥验证失败 这是因为我在生成密钥的时候修改了默认的文件名，默认是生成 id_rsa 还有 id_rsa.pub 两个文件，git 查找私钥的时候会寻找此名称的文件，所以被改名后自然是找不到私钥来解密了。那该如何才能识别呢，我试了一下，有两种方案。 ssh-add 第一种，是通过 ssh-add 将私钥添加进 ssh-agent 密钥管理器保管，git 解密服务端公钥将交给 ssh-agent 完成 ssh-add ~/.ssh/github 再测试一下 ssh 链接便可以正确链接 config文件 第二种，是通过 .ssh 下的 config 文件来设置对应的私钥 为了验证，请讲 ssh-add 添加的私钥清空。查看添加的私钥列表ssh-add -l 清空私钥列表ssh-add -D 为 .shh 文件夹添加 config 文件touch ~/.ssh/config 编辑 config 文件vi ~/.ssh/config 添加主要配置Host github HostName github.com IdentityFile ~/.ssh/github :wq 退出后测试链接，可以看到也能成功连接了简单解释一下，Host是一个简称，主要映射HostName，而IdentityFile则是私钥文件的位置，也就是说，测试连接的时候可以换成以下的命令ssh -T git@github 主机名 github 会自动转化为 github.com 不难想，通过 config 这种方案可以简单地配置多账户、多托管平台的 ssh key，所以我自己是采用了这种方式。","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"github","slug":"github","permalink":"http://www.wuzhouyang.cn/tags/github/"},{"name":"coding","slug":"coding","permalink":"http://www.wuzhouyang.cn/tags/coding/"},{"name":"git","slug":"git","permalink":"http://www.wuzhouyang.cn/tags/git/"}]},{"title":"Angular2(4) 中动态创建组件的两种方案","slug":"angular-two-way-to-dynamic-create-component","date":"2017-03-27T09:38:33.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-two-way-to-dynamic-create-component/","link":"","permalink":"http://www.wuzhouyang.cn/angular-two-way-to-dynamic-create-component/","excerpt":"","text":"上例子：https://github.com/wuzhouyang/angular-dynamic-component-example 接触 angular2 也有好几月了，由于在做的项目dom的操作貌似比较频繁，而且并不能针对dom来编程，这样的话与模板的耦合度便十分大，所以只能针对组件编程，动态加载组件来实现项目中相关的功能，那就不得不用到angular2中一些比较低等级的api。此文要记录的便是目前用到的两种动态创建组件的方案。 （一）动态加载已经声明的组件针对我的项目场景：用户拖动相关的块到特定区域，区域中便会生成相应的UI控件，此UI控件有自己的模板、行为等等。生成UI 后便会在区域中显示出来。所以我觉得将UI控件封为一个小组件，再动态加载，是个不错的方案。angular2中是如何动态加载组件的？ 要实现这个功能，得先简单了解angular2 中相关的api ViewChild：一个属性装饰器，用来从模板视图中获取对应的元素，可以通过模板变量获取，获取时可以通过 read 属性设置查询的条件，就是说可以把此视图转为不同的实例 ViewContainerRef ：一个视图容器，可以在此上面创建、插入、删除组件等等 ComponentFactoryResolve：一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上 有了这三个，一个简单的思路便连贯了：特定区域就是一个视图容器，可以通过 ViewChild 来实现获取和查询，然后使用ComponentFactoryResolve将已声明未实例化的组件解析成为可以动态加载的 component，再将此component 呈现到此前的视图容器中 为了实现此功能，我写了一个简单的例子我单独写了一个特性模块来测试，下面是结构图 特性模块涉及到 lazyload 的知识，我也不多讲了。直接看结构说明 dy1.component.ts dy2.component.ts 这两个就是将要动态加载的组件，内容不多，就是为了测试，如图 dynamic.component.ts 这个是此特性模块对应的组件实例，用于声明一些逻辑动作。简单看看此组件代码 可以看到在顶部导入处必需的三个都在。在组件类的顶部我通过模板变量的方式获取了此组件模板视图上了一个元素来作为视图容器，可以看看模板的代码 红框处便是我们要在上面动态加载组件的容器。看看获取容器的代码 通过模板变量名获取，然后 可以通过 read 选项设置为一个 ViewContainerRef ，最终在生命钩期 ngAfterViewInit 过后便会获取此区域的一个 ViewContainerRef 实例。看看主要的加载组件函数 我们已经通过组件类的构造函数注入了ComponentFactoryResolve服务，现在便可以调用其方法来解析得到一个 componentFactory 了，resolveComponentFactory 解析一个已经声明的组件得到一个可动态加载的 componentFactory，这里的DY1Component我们已经在顶部导入了。然后我们可以直接调用容器的createComponent函数将解析出来的componentFactory动态呈现到容器视图上。 然后我们就可以开心的运行、点击 ”动态加载组件“ 的按钮了。。不开心的是，报错了，相信我们可以得到这样的报错 原来动态加载的组件必须声明在特性模块的 entryComponents 中，下面是angular官网对于entryComponents的说明 Specifies a list of components that should be compiled when this module is defined. For each component listed here, Angular will create a ComponentFactory and store it in the ComponentFactoryResolver . 就是说此处声明的组件 Angular 都会创建一个ComponentFactory并将其存储在ComponentFactoryResolver中，也就是动态加载必需的步骤。所以我们将其加到特性模块 entryComponents中 然后我们又可以开心地运行，点击了。。。然而这次我们又得到另一个错误了 意思就是DY1Component 还没有声明 — — ||| 。 所以还需要将要动态加载的组件声明为是此特性模块的组件，如图 然后这次可以开心的看例子了 对于这个方案，上面展示的是最简单的一面，没有考虑到项目的优化还有代码的简洁。项目的优化问题体现在后期项目的压缩和预编译中，如果我们是想要通过组件的名字来动态加载组件，可能在优化有组件的名字都被统一压缩成一个字母，所以会导致找不到组件的问题；代码的简洁呢因人而异，我是喜欢保持根 module 的简洁，所以有必要另起文件来作为媒介。 说一说改进的方式新建一个管理类 导入动态加载的组件，声明一个供名字获取组件的变量，还有一个供根模块声明的变量 接下来就可以修改之前的引用代码了： 可以看到当动态组件多的时候，根 module还是能保持简洁。并且在根组件中可以通过名字获取对应的组件，不怕后期项目优化的影响。 （二）动态创建模块的方式来加载动态创建的组件不同的需求有不同的方案，对于上面的需求与方案无疑是很适合的，但是需要我们先创建好组件，再声明到根 module 中，至少缺失了一些灵活性。现在我又有了另外一个项目场景：我拖动生成了UI 控件，只是为了展示对应的样式，UI控件是需要第三方环境支持的，所以我需要加工拖动的数据，抛给后台处理，后台返回包含表示模板、组件的字符串的 JSON 数据回来，然后我通知另外一个网站，此网站包含了第三方环境，让他们去动态创建这些组件。一句话概括，就是我要动态创建不存在的组件而不是已经声明的组件。要完成动态创建组件的，我们得先看看相关的api Compiler：用于在运行时运行angular编译器来创建 ComponentFactory 的服务，然后可以使用它来创建和呈现组件实例 其实最简单的了解这一个就能实现了，我们知道 容器创建和呈现组件的函数需要一个 ComponentFactory，而Compiler能够在运行时动态创建一个ComponentFactory，那就十分符合需求了。 我新增了一些代码 这些都是在根组件中的代码，引入了 Compiler 服务。新增一个 createModule函数，通过 Component 和 NgModule 修饰器动态创建新的组件和模块，然后调用 Compiler 的 compileModuleAndAllComponentsSync 方法获取一个新的ComponentFactory。然后容器的呈现还是一样，直接 createComponent。在模板的按钮中设置对应的动作后就可以开心的运行和点击了。。 这次十分顺利，没有任何报错。可能我们会有疑惑，这个不也还是事先声明了动态的组件。其实只是我这个例子展示的问题，这里的 模板、组件类都是可以动态当成参数设置的，下面此图是我在项目中用到的 aot build的问题使用了这种方案，在项目正常开发预览的时候是没有任何问题的，但是当我构建项目（aot 等）运行的时候，就会出现下面报错 看错误可以知道在项目构建后是缺失angular编译器的，原因就是使用了AOT后已经是预编译了，编译器就会从中移除。为了解决这一问题，我们可以在这个把 compiler 编译器在构建的时候打到当前的特性包中 通过此处代码就可以将一个angular 编译器打到当前包中。再次运行build构建，可以看到已经没有之前的错误了，但是缺因此得到另一个错误 此错误暂时没能解决，待更新！","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"}]},{"title":"vps - FTP","slug":"vps-ftp","date":"2017-03-22T16:55:06.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"vps-ftp/","link":"","permalink":"http://www.wuzhouyang.cn/vps-ftp/","excerpt":"","text":"以下命令都通过普通用户创建，linux版本 centos7 作为远程服务器，ftp也是必不可少的，在此简单记录一下自己ftp的搭建和配置。 安装vsftpsudo yum install vsftpd -y 确保成功安装vsftpd -v 启动vsftpd服务sudo systemctl start vsftpdsudo systemctl enable vsftpd 如无意外，现在可以直接通过本机打开ftp了，我用的是 开源多平台的Filezilla ，默认端口会自动识别为21，此图为Filezilla匿名登录配置 毕竟匿名用户还有默认端口会导致一些不安全行为，所以再稍微配置一下 创建ftp用户sudo adduser 你的ftp用户名 -d 路径 -s /sbin/nologinsudo passwd 你的ftp用户名 由此创建一个匿名用户，只用于ftp登录访问特定的文件夹，不能用于登录ssh。并创建密码。 修改ftp监听端口sudo vi /etc/vsftpd/vsftpd.conf 在ftp配置文件最后追加listen_port= 其他端口 随后重启ftp服务sudo systemctl restart vsftpd 防火墙添加新添加的端口sudo firewall-cmd --zone=public --add-port=端口/tcp --permanent 重启防火墙sudo firewall-cmd --reload 这样理论上已经可以使用新的匿名用户登录ftp了，但是在修改完端口后能成功连上ftp却一直报一个错误 最后添加ftp被动模式解决 : pasv再次修改ftp配置文件，追加pasv_enable=YESpasv_min_port=随机数pasv_max_port=随机数 两个随机数是一个端口范围，只要是正确的端口且都大于1023就行。随后添加此端口范围到防火墙中sudo firewall-cmd --zone=public --add-port=随机数-随机数 --permanent 重启防火墙即可 其他配置限制ftp用户只能访问特定的目录，不能查看父级目录修改ftp配置文件，直接追加：chroot_local_user=NOchroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_list 然后在vsftpd目录下新建 chroot_listsudo vi /etc/vsftpd/chroot_list 在里面添加要限制的用户名，保存即可。这里有点药注意的，如果想限制只能访问自身的目录，需要对用户的根目除去写的权限，不然连接的时候会错： 需要如下操作sudo chmod a-w ftp的用户根目录 最后保存重启 vsftpd 服务便可正确连接服务器。","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"vps","slug":"vps","permalink":"http://www.wuzhouyang.cn/tags/vps/"},{"name":"linux","slug":"linux","permalink":"http://www.wuzhouyang.cn/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://www.wuzhouyang.cn/tags/centos/"},{"name":"ftp","slug":"ftp","permalink":"http://www.wuzhouyang.cn/tags/ftp/"}]},{"title":"购入 MacBookPro 2015 一台","slug":"new-mac-book-pro-2015","date":"2017-03-20T10:16:06.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"new-mac-book-pro-2015/","link":"","permalink":"http://www.wuzhouyang.cn/new-mac-book-pro-2015/","excerpt":"","text":"记录于 2017年3月20号 用了四年的联想笔记本终于该放下了，大一的时候什么都不懂就跑华强北自己买笔记本去，笔记本形形色色，而我毫无选购经验，果不其然就被某销售员拉了过去，询问了我的要求后便给我推荐了现在在用的笔记本。一开始我是犹豫的，于是跑到别的地方看了几眼，后来又遇到此销售员，死缠烂打，还打开了某电脑报价平台查询此笔记本的价格，比他的报价高不少。 我还是入坑了。毕竟拥有人生第一台笔记本是多激动的事情，激动到什么都不管了。 所以我拥有了人生第一台 i3 + 610m 的笔记本… 时至今日，它的质量还是很好，只不过我已经无法忍受它的运行速度了，应该说我早就无法忍受了。 因为入了前端的坑，所以最近梦想着拥有一台 MBP。无奈现在已经17年，新款的机器实在无能为力，所以寻寻觅觅一个月，看中 2015 款840中配，我想应该能够满足我的需求。所以我又花了大半个月在闲鱼上面淘，终于给我淘到了一位大哥的机器，机器几乎99新。而且大哥信用不错，一切交易都顺利，这应该是我最大胆的一次购买了…","categories":[{"name":"My Life","slug":"My-Life","permalink":"http://www.wuzhouyang.cn/categories/My-Life/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.wuzhouyang.cn/tags/mac/"}]},{"title":"升级Angular2.4 和 Webpack2.2后遇到的 AOT build 中sass图片不打包的问题","slug":"angular2-4-webpack2-2-sass-image-not-pack","date":"2017-02-15T01:36:49.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular2-4-webpack2-2-sass-image-not-pack/","link":"","permalink":"http://www.wuzhouyang.cn/angular2-4-webpack2-2-sass-image-not-pack/","excerpt":"","text":"过了个年，angular直接就到4版本了。看了看我还停留在2.1。而且项目差不多一俩月没维护，刚git pull下来运行就看到很多插件的依赖警告，作为有轻度强迫症的我，果断忍受不了，所以把 angular升级到了2.4，webpack升级到了2.2。 升级后有些操蛋，插件导致各种的 start 、build问题接踵而来。起始其他的还算好，主要都是插件的用法更新了。让我难受几天的是 webpack 进行 aot build 的问题。 我在项目中用到的是sass，就是css的预编译器。在angular的component中我是直接这样使用的 angular是不能直接识别scss的，所以需要webpack配置一下loader，我用到及作用的loader依次为 ： sass-loader，css-loader，to-string-loader 为了处理scss中的 url() 引用的图像文件，还得使用 url-loader 大概过程是这样理解sass-loader 识别styleUrls中引用到的scss，编译为css后传给css-loader，css-loader 在处理 url() 路径时会自动更改为 url-loader 设置的name对应的路径，url-loader 再根据文件的大小自动处理引用到的图像文件，由于css-loader 转完后没有返回字符串，angular styleUrls识别不了，所以最后 to-string-loader 将返回一个编译后的css字符串。 那么问题来了，过年前未升级版本的时候一切都能顺利，scss成功识别并替换了其中 url() 的路径，并打包了对应的图像文件。过年后回来升级了一下，scss中的 url() 路径是可以正确地替换，但是图片本身并没有被一起打包到 发布目录下。 于是我翻遍了google，尝试换了各种转字符串的loader 都没什么卵用。最后想想可能是url-loader的问题，所以更新了最新的，还是不行。换成了 file-loader 还是不行。。我只能说在gihub看了至少不下几十个的angular-seed，虽然都有涉及到如何使用sass，但是都没有在sass中引用到图片。我也在 stackoverflow 逛了许久，可惜的是相关的问题少，回答更少。 可能是水平太菜了，一个问题都纠结着我小几天。最后我想了想，用了一个比较蠢的方法。首先在webpack的plugins中配置一个插件直接复制所有的图像文件到发布目录中 然后在 url-loader 中修改文件路径使css-loader处理 url() 时替换成相应的，这样在build之后就能找到图像资源了。。 虽说是没问题了，但是糟点满满啊。直接复制图像资源本来就不符合webpack的模块打包机制了，而且这样一复制等于把某个文件夹下的全部图像都复制过去，虽说不会增加流量，但是以后如果图片分多个文件夹，那不好管理。期待以后能慢慢解决此问题。留！ 17-3-24 更将项目升级至Angular4，此问题不复存在！","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"},{"name":"scss","slug":"scss","permalink":"http://www.wuzhouyang.cn/tags/scss/"},{"name":"webpack","slug":"webpack","permalink":"http://www.wuzhouyang.cn/tags/webpack/"},{"name":"aot","slug":"aot","permalink":"http://www.wuzhouyang.cn/tags/aot/"}]},{"title":"vps - Shadowsocks","slug":"vps-shadowsocks","date":"2017-01-18T07:34:31.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"vps-shadowsocks/","link":"","permalink":"http://www.wuzhouyang.cn/vps-shadowsocks/","excerpt":"","text":"注意：以下命令我都是通过普通用户使用 配置完一些基本的东西，接下来可以配置shadowsocks了。买国外vps怎能少得了ss。由于作者github已经删除了源码，我也不懂源码安装 -_- || 。所以我们直接奔向作者文档 ：https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E可以直接查看和安装，也可以直接看下文。 安装shadowsocks直接yum安装sudo yum install python-setuptools &amp;&amp; sudo easy_install pipsudo pip install shadowsocks 普通用户记得加sudo，可以加 -y忽略所有操作最后你会看见愉快的Successfully 启动shadowsocks文档有两种启动方式，一种直接命令行敲，我看这头太晕，所以我推荐用配置文件启动。shadowsocks默认是没有配置文件的，我们需要自己创建，转到 /etc 目录，创建 shadowscocks 目录 sudo mkdir shadowsocks，转到新建目录下创建新的配置文件cd shadowsocks &amp;&amp; sudo vi ss.json。填入以下一些字段对应的值即可：&#123; \"server\":my_server_ip, \"server_port\":my_server_port, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":my_shadowsocks_password, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false&#125; 照着文档简单理解解释一下 server 服务端监听的 IP地址，就是vps的IPserver_port 服务端监听的端口local_address 本地地址，一般不做修改local_port 本地端口，一般不做修改password shadowsocks密码timeout 超时时间 秒method 加密方式，一般就选aes-256-cfb或RC4-MD5fast_open 系统内核&gt;=3.7.1的可开启，优化速度性能 我自己就是简单地配置下 请注意，当你的server配置为你的vps ip的时候，在做启动或者自启动的时候可能会遇到报错的情况，如 此时请将 server设置为0.0.0.0（被这个问题困扰了很久） 对了，如果防火墙运行中，记得打开防火墙端口sudo firewall-cmd --zone=public --add-port=端口/tcp --permanentsudo firewall-cmd --reload 然后可以开心地启动了sudo ssserver -c /etc/shadowsocks/ss.json -d start` -d start代表后台运行 shadowsocks客户端打开ssserver了，怎么连接呢，那就要配置客户端的shadowsocks了。在这里只讨论windows下的安装。奔作者github下载客户端 https://github.com/shadowsocks/shadowsocks-windows噼里啪啦安装完打开。根据图示设置刚才设置的shadowsocks配置： 填入相关参数后选中连接即可： 系统代理模式有两种，一般选择PAC模式即可，减少翻墙流量： 然后你就可以愉快的google了 自启动作者并没有提供自启动的说明。按照搜索我列几种自启动的方法。 第一种是最简单的，直接添加相应的启动命令到 /etc/rc.local下便可以。记得给rc.local加上相应的执行权限 chmod +x /etc/rc.local 第二种是创建一个新的服务，利用 Systemd。在 /etc/systemd/system下新建服务文件sudo vi /etc/systemd/system/shadowsocks.service 在/lib/systemd/system下也可以，但是前者优先级更高： 简单地说明一下（我也是参考网上来的）： [Unit] 服务的说明 Description 服务的描述 After 服务的类别描述 [Service] 运行服务的参数配置 type 后台运行的形式 ExecStart 服务启动要运行的命令 PrivateTmp 给服务分配独立的临时空间 [Install] 服务安装的相关设置 WantedBy 可设置为多用户 然后利用 systemctl 工具管理： 启动：sudo systemctl start shadowoscks 查看状态 ： sudo systemctl status shadowsocks 允许开机自启动 ：sudo enable shadowsocks 第三种是使用supervisor守护进程，确保ss在无意间挂掉能自动重启安装 supervisorsudo pip install supervisor 直接使用模板创建配置文件（root权限）sudo su - root -c \"echo_supervisord_conf &gt; /etc/supervisord.conf\" 直接vim编辑配置文件sudo vi /etc/supervisord.conf 直接快捷键 GA+Enter键在文尾添加shadowsocks配置： [program:shadowsocks]command=ssserver -c /etc/shadowsocks/ss.json -d startautorestart=true autostart=trueuser=rootstderr_logfile = /var/log/supervisor/err.log 相信看属性知道啥意思，stderr_logfile是添加出错时的记录文件，以便排错。 然后就可以通过服务端supervisor来运行了sudo supervisord -c /etc/supervisord.conf 通过客户端命令来管理刚添加的program： 启动：sudo supervisorctl start shadowsocks 停止：sudo supervisorctl stop shadowsocks 重启：sudo supervisorctl restart shadowsocks 如果修改了配置文件，记得更新一下sudo supervisorctl update 如果想杀死 supervisord进程ps -ef | grep supervisord 会看到例如 kill掉对应端口就行kill -s SIGTERM 2254 将 supervisor 添加进开机自启sudo vi /etc/rc.local 在rc.local后面添加启动命令即可sudo supervisord -c /etc/supervisord.conf supervisor还可以利用web前端管理，在配置文件下加上：[inet_http_server]port = 0.0.0.0:9001username = 登陆用户名password = 登陆密码 防火墙如果是开启的状态记得添加端口sudo firewall-cmd --zone=public --permanent --add-port=9001/tcpsudo firewall-cmd --reload 在任意浏览器输入你的vps 公网IP:9001登陆后就可以进行管理了 做完任一个方案就可以安心reboot，实验是否正确自启了。 关于shadowsocks的启动错误之前也有说过了，在做自启动的时候如果shadowsocks的配置不正确的话是会启动失败的。我就遇过一个自启动的问题，无论是rc.local还是配置systemd均无法正确自启动shadowsocks。后来才发现原来是可以查看shadowsocks的报错信息的。ss默认的日志信息在/var/log/shadowsocks.log中。如果确认是shadowsocks的问题的话，请查看日志文件cat /var/log/shadowsocks.log 如果有报错会类似 直接谷歌最后一行错误信息。我就直接谷歌后得到了答案 所以根据我上面说的，server 最好配置为 0.0.0.0。 大概就是这些了，以后想起点什么再编辑！","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"vps","slug":"vps","permalink":"http://www.wuzhouyang.cn/tags/vps/"},{"name":"linux","slug":"linux","permalink":"http://www.wuzhouyang.cn/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://www.wuzhouyang.cn/tags/centos/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://www.wuzhouyang.cn/tags/shadowsocks/"}]},{"title":"vps - 我的初始配置","slug":"vps-init","date":"2017-01-16T05:52:13.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"vps-init/","link":"","permalink":"http://www.wuzhouyang.cn/vps-init/","excerpt":"","text":"vps拿到手了，没必要急着就搞什么LNMP啊，shadowsocks啊。安全起见，先来简单配置一下 修改root密码vps提供商在你创建实例后会自动分配一个root账户，密码都是随机组成，要记起来可不容易，所以复制一下你管理面板上的密码，登陆xshell进行修改。 修改后重新登陆记得修改xshell的连接账户。 创建一个普通用户为了安全不推荐直接用root账号进行操作。可以简单地创建一个普通用户，给予一定的权限。手滑打错密码了。。 这个时候就可以用创建的用户登陆了。但是在此之前还是用root账户给新用户加root权限吧。使用 visudo 找到下面root一行，在后面添加新用户的便可。 编辑完按下 Esc 键，加上 :wq 即可保存退出编辑。这些都是 vim 知识。 修改默认ssh端口ssh默认端口大家都知道。所以很容易遭受别人的密码攻击，直接对准其端口暴力穷举问你怕不怕。虽然没啥东西好怕的。。-_- || 。但还是来换下端口吧。vim编辑ssh配置文件，在 etc/ssh/sshd_config 文件找到Port一行把Port的注释（＃号）去掉，换成自己想要的端口就好，注意可用端口的范围。 然后 :wq保存退出，重启ssh服务 systemctl restart sshd接着请记得要配置打开ssh在防火墙的端口，因为我用的centos7，防火墙已经改为firewalld，且默认是关闭的。但为了保险起见，来看看firewalld的状态 systemctl status firewalld: 如果防火墙运行了，记得要打开ssh的端口firewall-cmd --zone=public --add-port=我的端口/tcp --permanent 简单说明一下吧: firewall-cmd ——— 防火墙的命令客户端zone ——— 网络连接的信任级别permanent ——— 永久开启 其中的zone不太熟悉，网上找了个说明贴着，以备查阅 简单地配置好firewalld后记得重启服务 firewall-cmd --reload查看之前的配置操作结果 firewall-cmd --zone=public --list-all 看到services里面有刚才加进去的ssh就是了。其实firewalld默认已经有加上ssh服务了，但是我不知道为什么手动换了ssh的端口，还需要去打开防火墙端口。 重启做完简单的配置就可以放心大胆地 reboot 了。新的连接记得用新用户、新端口登陆！","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"vps","slug":"vps","permalink":"http://www.wuzhouyang.cn/tags/vps/"},{"name":"linux","slug":"linux","permalink":"http://www.wuzhouyang.cn/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://www.wuzhouyang.cn/tags/centos/"},{"name":"vultr","slug":"vultr","permalink":"http://www.wuzhouyang.cn/tags/vultr/"}]},{"title":"vps - 前言","slug":"vps-preface","date":"2017-01-15T03:11:22.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"vps-preface/","link":"","permalink":"http://www.wuzhouyang.cn/vps-preface/","excerpt":"","text":"为何记录很久之前就买了 vps 来玩了，一开始的时候并不懂 linux 。跟着网上搜的教程一步步搭建了可以用的 shadowsocks 。一开始只是为了翻墙用，所以搭建完后也就没有再去管理了。我用的是 vultr 这个 vps 提供商，由于有优惠政策，所以一直相当于免费用了半年左右。如今半年早已过去许久，当我再连接 vps 的时候却发现一切都生疏了。之前搭的 shadowsocks 经验也都消失了，记得之前还看过一阵子 《鸟哥的linux私房菜》，如今想想，并没有记起什么。所以，我打算从头再玩玩 vps ，同时记录下所有的配置过程，希望在以后遗忘的时候还能看看这些文章从而记起一些点点滴滴。 vps的选择呃。。免费赠送的美刀都消磨得差不多了，想想 vultr 每个月最低5美刀的价格，心里还是嫌贵了，所以我后来又找了另外的提供商 - - 就是人皆尽知的搬瓦工啦。在搬瓦工上我买的是年付18刀左右的凤凰城机房vps。机智的我只付了一个月的费用打算试试。然后啪啦啪啦简单地搭好了 shadowsocks，然后客户端一连，果然速度6得飞起。于是。。。我又晾在一边没去管它了。几天后当我想要 xshell 连上去敲命令的时候，却发觉命令行敲着十分卡，经常一个命令等个十几秒，有时候 vim 直接就卡机了。shadowsocks也刷不出谷歌来了，于是我重装vps系统，然而问题还是没有解决。估计我重装了得有3次吧。心烦意乱的我看看 xshell 还有之前 vultr 的 vps 记录，于是我登了上去，发觉还能登陆，而且命令行敲得十分顺利，谷歌打开还是一如既往的速度。所以想了很久，还是续费我的vultr吧。 可能我是个例吧，在这里并不是恶意贬低搬瓦工 ~_~ 。只是个人来说我还是推荐 vultr。至于说优点体现在何处，那我说说目前感觉到的几点吧 按时收费，只有当你有vps实例存在的时候才会按时扣费。也就是说当你destroy所有vps的时候你的余额是不会减少滴； 有日本机房，之前貌似日本线路并不是直连的，听说现在已经改为直连大陆了，当然速度快了很多； 配置还行，最低5刀的有 768 MB内存。且都是SSD。最重要的是全部都是KVM架构，相比搬瓦工的openvz，可以做的事情多了一些。。。当然搬瓦工物美价廉，还是很可以的。由于我用的是vultr。所以以后我所记录的都是与之相关的，不过也没啥相关的。。-_- ||| 开始记录吧说了一些废话。还是动手来的好。由于已经配置了一台vps了，所以我新创建了一台，从零开始记录这几天的配置吧。","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"vps","slug":"vps","permalink":"http://www.wuzhouyang.cn/tags/vps/"},{"name":"linux","slug":"linux","permalink":"http://www.wuzhouyang.cn/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://www.wuzhouyang.cn/tags/centos/"},{"name":"vultr","slug":"vultr","permalink":"http://www.wuzhouyang.cn/tags/vultr/"}]},{"title":"更新了一下个人的一个Angular Starter","slug":"angular-starter","date":"2016-12-15T06:36:06.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-starter/","link":"","permalink":"http://www.wuzhouyang.cn/angular-starter/","excerpt":"","text":"https://github.com/wuzhouyang/angular4-seed-starter 实现aot、lazyload、hmr、webpack+scss等功能。没有集成测试框架和功能，在小团队里几乎不用接触测试。。所以。。 17-1-16 更 已更新至angular 2.4。如果结合其他插件可能build会有问题。完全自己写就不会有问题。这个是插件版本依赖的问题。 17-03-24 更 已更新至angular 4.0.0。 解决使用scss build的时候不能打包图片资源的问题。升级完后无论是dev还是build的速度几乎快了几倍，这是个人的感觉！","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"},{"name":"scss","slug":"scss","permalink":"http://www.wuzhouyang.cn/tags/scss/"},{"name":"javascript","slug":"javascript","permalink":"http://www.wuzhouyang.cn/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://www.wuzhouyang.cn/tags/webpack/"},{"name":"github","slug":"github","permalink":"http://www.wuzhouyang.cn/tags/github/"},{"name":"npm script","slug":"npm-script","permalink":"http://www.wuzhouyang.cn/tags/npm-script/"},{"name":"hmr","slug":"hmr","permalink":"http://www.wuzhouyang.cn/tags/hmr/"},{"name":"css","slug":"css","permalink":"http://www.wuzhouyang.cn/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://www.wuzhouyang.cn/tags/css3/"}]},{"title":"购入 fujifilm xt10 一台","slug":"new-fujifilm-xt10","date":"2016-12-04T09:16:06.000Z","updated":"2017-06-08T02:04:43.000Z","comments":true,"path":"new-fujifilm-xt10/","link":"","permalink":"http://www.wuzhouyang.cn/new-fujifilm-xt10/","excerpt":"","text":"记录于 2016年12月4号 购入富士无反 XT-10 一台，套机（16-50 mm 富士狗头） ~","categories":[{"name":"My Life","slug":"My-Life","permalink":"http://www.wuzhouyang.cn/categories/My-Life/"}],"tags":[{"name":"无反","slug":"无反","permalink":"http://www.wuzhouyang.cn/tags/无反/"}]},{"title":"Angular2 第三方插件AOT出错的问题（.metadata.json）","slug":"angular-third-plugin-aot-problem","date":"2016-11-23T07:53:15.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-third-plugin-aot-problem/","link":"","permalink":"http://www.wuzhouyang.cn/angular-third-plugin-aot-problem/","excerpt":"","text":"用了一个第三方的ng2拖拽插件ng2-dnd，今天闲来无事的aot build了一下发现错误了 如果只是直接在sharedModule下import其模块或者不使用forRoot，则会报另一个错 写ng2最烦就是构建的问题了。翻了插件的github，发现只有一条有大概说到这个问题的issue，但是没有具体的解决方案，所以我只能提一条上去了。。但是作者貌似2个月没更新了，也不知道看不看得到。后来我翻了angular的github issues，其中发现料 就是说插件必须包含一个对应的 .metadata.json文件，才能在AOT中正确地编译。。于是回头翻了翻其他插件，真的有 metadata.json文件而出问题的这个并没有。那这就只能靠开发商提供了。我只能再次跑到作者gihub下反映了。。当然还有一个解决方法，就是把作者的源码clone下来作为自己的代码使用，只是自我感觉有些不妥。还是等待作者修复吧。 17-01-16 更 许久没用此插件，插件作者已经耐心回复并更新了。https://github.com/akserg/ng2-dnd/issues/84","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"}]},{"title":"父组件的样式应用到子组件中（scss）","slug":"angular-parent-child-style","date":"2016-11-22T08:52:55.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-parent-child-style/","link":"","permalink":"http://www.wuzhouyang.cn/angular-parent-child-style/","excerpt":"","text":"今天在敲代码的时候，做了一个总体的父组件页面，样式都写好了。想着写个子组件，在父组件中引用，结果，发现问题了：尽管父组件写好了样式并引用了，子组件也在模板上应用了对应的class，但是就是不起作用。为此，翻了一下官方文档，果然找到料 简单啦，我只要在父组件要应用到子组件的样式类前面加个 /deep/ 就好啦。然而，sass编译器告诉我编译错误 其实这样直接编译是可以的，只是看不惯赤裸裸的错误提示，所以灵机一动，把/deep/变成变量就好了 ok，可以继续敲代码了 = = || 16-11-25 更今天遇到了新的需求：已知有了一个父组件 父组件的模板引用了一个子组件： 子组件呢还能动态添加子组件，就叫孙组件吧-_- ||，嵌套于之中。 所以问题来了，我们已经知道在父组件的样式加上 /deep/ 就能将样式应用于全部的子组件中，但是现在我并不想要在父组件下控制子组件的样式，在父组件中只需要给自组件的上一层加点样式，所以还是依然可以直接使用 /deep/，就像 所有之间的样式都会应用到 .content下面，所以子组件默认被应用了。这是我之前说的。现在有新的需求，子组件管理自己以及内部（动态创建的孙组件）的样式，为了方便后来的样式提取（我是这样想的-_- ）。ok，按照前面的思路，就是给子组件的样式加个 /deep/ 就好了，但是最终的结果就是子组件的样式会覆盖到全局去，WTF！于是又查了文档，发现了料 那我直接选择子组件的上一层，再加个 /deep/ 应用所有孙组件不就行了，就像 对于sass的，要转为变量 #{&#39;:host&#39;}不然编译后没有效果。 结果发现符合预想，ok 可以继续敲代码了 -_- ||","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"},{"name":"scss","slug":"scss","permalink":"http://www.wuzhouyang.cn/tags/scss/"}]},{"title":"Angular2 简单指令实现多主题功能（个人思路）","slug":"angular-multi-themes-directive","date":"2016-11-15T01:09:45.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-multi-themes-directive/","link":"","permalink":"http://www.wuzhouyang.cn/angular-multi-themes-directive/","excerpt":"","text":"多主题指的是我们的web程序可供用户选择相应的样式，纯前端实现与传统的结合后台实现不同，用户所选即所见，也不用刷新页面。结合ng2做特性模块的多主题，一开始是想要实现不同主题按需加载的，苦于找不到好的方案，可能能力太水了。所以现在的方案就是按需加载模块的时候，需要加载其对应的全部样式，然后通过简单的指令和服务来动态设置组件的class。我以sass为例，简单地列出模块对应的样式文件 可以看到，可以将主题大致分为一个公共的，还有就是不同色彩的文件，因为一般一些定位布局什么的都不会修改，只有配色才会变化。这里分为多个文件是便于维护。 在组件类中可以引入多个对应的样式文件 这样一来在加载这个模块组件的时候就会相应地加载这些样式文件了。 下面可以写一个主题服务类，主要用来设置主题、修改class的 这里先定义一些数据类型接口，没啥。。就是方便智能提示（用的vscode），需要一个主题的key，因为纯前端的话主题标识是扔到localstorage里，所以需要一个key；还有一个指令实例的数组容器，主要用于后面循环操作以及注销实例用。 看看服务的主要函数 也就是几个重要的函数，注释上面有说明。这里说一下为什么要有销毁功能，因为这里的服务是全局的、单例的。所以实例数组会随着用户的操作慢慢增加元素，为了防止内存溢出，就可以结合指令的生命钩子来注销实例啦！ 看完服务再看看简单的指令，指令在这里主要是为了获取其被应用到的dom元素 很简单，主要就是添加此实例到服务中，初始化、销毁指令等等，都是调用服务中的方法。这里主要说一下ng2中的 Rederer、ElementRef。 Rederer官方说法是可以修改dom元素，而不会局限于浏览器平台上。ElementRef则能获取当前应用指令的dom元素。这样一结合就可以开心地修改dom啦！ 模板上的应用 可以看到，直接在想要切换样式的元素上应用指令。需要注意的是，必须要有对应主题类，不然是没有任何样式的。 但是这种方法有一定的局限性，就是得按照规范来，比如得提前统一好主题类的名字、然后需要在改变样式的dom上多加一层来确保不会影响原有的class。至于优化，后面发现问题再弄吧 —… — |||","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"},{"name":"scss","slug":"scss","permalink":"http://www.wuzhouyang.cn/tags/scss/"}]},{"title":"Angular2+Webpack+HMR问题（热替换）","slug":"angular-webpack-hmr","date":"2016-11-07T03:24:40.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-webpack-hmr/","link":"","permalink":"http://www.wuzhouyang.cn/angular-webpack-hmr/","excerpt":"","text":"在ng1时代，想要实现编码的所见即所得个人感觉配置是很简单的，无非就是gulp+browserSync，而且快速。但是在ng2时代，配合webpack做热替换是个头疼的事情，个人感觉相关文档和解决方案太少了，翻了很久的google和github才找到一点解决方案。下面说一下我是怎么做的：首先我们需要这俩个插件 angular2-hmr主要用来在根模块启动时做相关设置angular2-hmr-loader主要用于webpack loaders中，既然说需要那就需要吧npm install angular2-hmr angular2-hmr-loader --save-dev 把main.ts修改一下，如下图 切换到根模块 app.module.ts下，引入刚才安装模块的相关函数 声明一下类型 对根模块类进行改造 切换到你的webpack配置文件在匹配ts文件的loader中加入angular2-hmr-loader 你也可以像图中一样，在程序启动打包的时候设置一下全局的变量来判断是不是生产环境，一般生产环境不用配置热替换了 大功告成，安心启动程序吧。不过这个热替换并没有想象中那么美好，由于项目中用到了bootstrap，举个例子，但我打开一个modal的时候，此时想要更改modal的css样式，但是热替换后modal竟然隐藏了，还有其他的类似下拉按钮组，热替换后一样都是隐藏了下拉部分。所以留待研究吧。我还是偏向于 gulp+browserSync，至于这么结合webpack，再看吧。。。","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"},{"name":"webpack","slug":"webpack","permalink":"http://www.wuzhouyang.cn/tags/webpack/"},{"name":"hmr","slug":"hmr","permalink":"http://www.wuzhouyang.cn/tags/hmr/"}]},{"title":"ng2-translate 结合特性模块问题","slug":"angular-translate-feature-module-problem","date":"2016-11-03T02:06:25.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-translate-feature-module-problem/","link":"","permalink":"http://www.wuzhouyang.cn/angular-translate-feature-module-problem/","excerpt":"","text":"在结合ng2-translate插件的时候，作者github主页并没有太多说明结合特性模块的使用。问题是这样的：因为考虑到我是使用路由的按需加载，所以一开始想要在共享模块（sharedModule）中使用ng2-translate并导出，就像图示 然后在每一个特性模块中导入sharedModule。这样是不会有任何效果的。按照angular官网的说法 按照约定，模块的静态方法 forRoot 可以同时提供并配置服务。 它接收一个服务配置对象，并返回一个 [ModuleWithProviders]只在应用的根模块 AppModule中调用 forRoot 。 如果在其它模块（特别是惰性加载模块）中调用它则违反了设计意图，并会导致运行时错误。 可以知道forRoot()只应该在根模块中使用。所以调整了代码： sharedModule中只导入和导出了相关模块（TranslateModule），因为在其他惰性加载的模块中要导入sharedModule。然后在app.module.ts根模块中配置一下 ok，程序可以正常按需加载特性模块，并实现多语言。（语言json文件的按需加载还没实现，后续工作）","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"}]},{"title":"lazyload 下特性模块导入另一个模块导致的路由问题","slug":"angular-lazyload-feature-module-import-other-module-router-problem","date":"2016-11-03T00:45:53.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"angular-lazyload-feature-module-import-other-module-router-problem/","link":"","permalink":"http://www.wuzhouyang.cn/angular-lazyload-feature-module-import-other-module-router-problem/","excerpt":"","text":"由于代码问题没有做子路由组件，都是采用特性模块（以后再做子路由）。遇到一个问题 结合lazyload每个模块下都会配有一个路由配置模块文件，当某个特性模块要导入另一个带有组件的模块时，假如把 routing.module配置文件放在 import里另一个模块的后面，就会导致想要通过路由定位到此此模块的时候自动定位到导入的那个模块 so ，解决方法是时时刻刻把路由配置文件放import首位","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.wuzhouyang.cn/tags/angular/"},{"name":"typescript","slug":"typescript","permalink":"http://www.wuzhouyang.cn/tags/typescript/"}]},{"title":"关于css3中linear-gradient中的百分比","slug":"css3-linear-gradient","date":"2016-07-21T09:12:58.000Z","updated":"2017-05-24T14:07:32.000Z","comments":true,"path":"css3-linear-gradient/","link":"","permalink":"http://www.wuzhouyang.cn/css3-linear-gradient/","excerpt":"","text":"相关阅读点《Css secret》第二章《背景与边框》 第五节《条纹背景》 正文在第二章《背景与边框》中第五节《条纹背景》中，谈到了css3的新属性值linear-gradient,但是这里并不是详细说明这个新属性的用法，这里主要是用它来完成背景条纹，来看看原文中的说明与演示。 假设我们有一条基本的垂直线性渐变，颜色从#fb3 过渡到#58a（参见图2-20）：background: linear-gradient(#fb3, #58a);​ 抛除兼容性前缀，linear-gradient 最简单的声明就是如上代码，接受两个颜色值参数，默认就是垂直渐变的。再来看如下原文： 现在，让我们试着把这两个色标拉近一点（参见图2-21）：background: linear-gradient(#fb3 20%, #58a 80%); 现在可以看到，在颜色值后面跟多一个对应的百分比值，虚线框中的渐变过渡被压缩了。第一个颜色的实色占了总高度的20%，第二个颜色的实色也占了总高度的20%，而渐变的过度则占了总高度的60%。当看到这里的时候我很好奇也很疑惑，为什么代码中并没有设置一个60%的值而为什么结果会有一个相同的值，书中也没有多说。说到底就是对这个属性的不熟悉，我翻阅mdn上面的文档，找到了这么一句： linear-gradient( 0deg, blue, green 40%, red ); /* A gradient going from the bottom to top, starting blue, being green after 40% and finishing red */ 从注释中可以清楚地知道，百分比是指某个颜色值距离起点的开始位置 。默认的渐变方式为从上往下，所以当某个颜色值设置了百分比后，便会从距离顶端相关的距离（百分比计算）开始填充实色。而渐变色会在顶部与尾部的中间填充。我们可以自己来验证相关的例子： 第一个我没有设置任何的百分比background:linear-gradient( red, orange); 得到的效果是这样的： 由于这个看不出默认的百分比是多少，所以接下来设置了background:linear-gradient( red 0%, orange 100%); 结果发现 效果跟上图并没有区别，所以如果我们不设置百分比的话，默认是根据颜色的个数来给每个颜色值设置的，最后一个颜色的百分比值就是100%，而起始的值就是0%，中间如果再有多个颜色值，则根据100/（个数-1）平均下去。相同的我们可以设置多个值例如background:linear-gradient( red, orange, yellow, green, blue, indigo, violet); background:linear-gradient( red 0%, orange 16.67%, yellow 33.33%, green 50.00%, blue 66.67%, indigo 83.33%, violet 100%); 上面这两个代码效果都是一致的 说了这么多，只知道了默认值，还不知道到底百分比是怎么工作的呢。那现在就再来写例子 首先来定义一个颜色值全部都为0的 background:linear-gradient( red 0%, orange 0%); 得到如下效果 还不能看出是什么原因导致的，接下来再设置一个0% 20%的background:linear-gradient( red 0%, orange 20%); 再设置一个0% 50%的background:linear-gradient( red 0%, orange 50%); 由此不难看出，红色部分是从顶端就开始着色的，而橙色部分是从设置的距离顶部的百分比位置开始着色，但把橙色设置为0%的时候，便会直接从顶部开始着色，就有了橙色完全遮盖住红色的效果，当橙色百分比值增加的时候，相应的就会产生一个距离，而这个距离的空间在一开始已经被红色着色了，所以才会有了后面的效果。 ps：如果设置第一个颜色的值呢？ 我们来设置一下第一个颜色的百分比background:linear-gradient( red 30%, orange 50%); 知道了百分比值的作用，再来看看什么情况下才会产生渐变的过度效果：我们已经知道，当默认不设置百分比的时候，是这样的 将红色设置0% 橙色50%后是这样的 我们再进行修改，将红色改为30% 橙色70%看看效果background:linear-gradient( red 30%, orange 70%); 所以上面的图中可以仔细看出，过度也是有个空间占比的，默认（红色0%，橙色100%）的渐变过渡占比为 红色0% 橙色50%的渐变过渡占比为 红色30% 橙色70%的渐变过渡占比为 所得得出结论，渐变过渡区的占比为总的空间（高度或宽度）减去上下两个着色块空间占比剩下的空间。 我们可以通过设置两个占比各为50%的颜色，看看渐变过渡区是否还存在background:linear-gradient( red 50%, orange 50%); PS：如果后一个颜色的百分比设置为比前一个颜色的百分比小呢，又代表什么意思？下面摘抄自原文 如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值 所以我们可以知道，如果前面有比当前的颜色值百分比大的，会自动将当前颜色值的百分比设置为前面颜色中的最大百分比值，下面的效果我们就可以知道了background:linear-gradient( red 50%, orange 40%); 其实就相当于background:linear-gradient( red 50%, orange 50%); 根据上面全部所说的，自己简简单单就能通过一个属性做出一个多重颜色线条的背景 background:linear-gradient( red 0%, red 14.3%, orange 0, orange 28.6%, yellow 0, yellow 42.9%, green 0, green 57.2%, blue 0, blue 71.5%, indigo 0, indigo 85.8%, violet 0, violet 100%); ps：解释一下，总共用了7种颜色。第一个颜色为red，此时整个背景已经由red覆盖，在这里为什么颜色都要设置两次，这是因为每个颜色需要一个起始着色点，然后还需要将两个颜色之间的渐变过渡区域覆盖为实色，消除过度效果。可以想象当没有了实色的覆盖，最终效果会是这样的background:linear-gradient( red 0%, orange 16.67%, yellow 33.33%, green 50%, blue 66.67%, indigo 83.33%, violet 100%);","categories":[{"name":"IT-Code","slug":"IT-Code","permalink":"http://www.wuzhouyang.cn/categories/IT-Code/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.wuzhouyang.cn/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://www.wuzhouyang.cn/tags/css3/"}]}]}